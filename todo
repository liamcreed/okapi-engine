
OPENGL
    - normal maps:


    #version 330 core
layout (location = 0) in vec3 a_pos;
layout (location = 1) in vec3 a_norm;
layout (location = 2) in vec2 a_uv;
layout (location = 3) in vec4 a_tang;

out vec3 v_pos;
out vec3 v_norm;
out vec2 v_uv;

out mat3 v_tbn;
out vec3 v_tang_pos;
out vec3 v_tang_cam_pos;


uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_proj;

uniform vec3 cam_pos; 



void main()
{
    gl_Position = u_proj * u_view * u_model * vec4(a_pos, 1.0);
    
    v_pos = vec3(u_model * vec4(a_pos, 1.0));   
    v_uv = a_uv;
    
    mat3 norm_mat = transpose(inverse(mat3(u_model)));
    vec3 T = normalize(norm_mat * a_tang.xyz);
    vec3 N = normalize(norm_mat * a_norm);
    T = normalize(T - dot(T, N) * N);
    vec3 B = cross(N, T);
    
    mat3 TBN = transpose(mat3(T, B, N));    
    v_tang_cam_pos  = TBN * cam_pos;
    v_tang_pos  = TBN * v_pos;

}

vec3 diffuse_color = texture(diffuse_map, uv).rgb;
float roughness = texture(orm_map, uv).g;

vec3 normal_color = texture(normal_map, uv).rgb;
vec3 norm;
if(texture(normal_map, uv).a == 1)
    norm = normalize(texture(normal_map, uv).rgb * 2 - 1);
else
    norm = normalize(v_norm);

float ambient_strenght = 0.0;
vec3 shadow_color = vec3(0.8,0.8,1);
vec3 ambient = ambient_strenght * diffuse_color * shadow_color;
  
vec3 light_direction = vec3(-10,-10,-10);
light_direction = normalize(-light_direction); 
float diffuse_lighting = max(dot(norm, light_direction), 0.0);

vec3 diffuse = diffuse_lighting * diffuse_color; 

float spec_intensity = 1 - roughness;
vec3 viewDir = normalize(cam_pos - v_pos);
vec3 reflectDir = reflect(-light_direction, norm);  

vec3 halfway_dir = normalize(light_direction + viewDir);  
float spec = pow(max(dot(norm, halfway_dir), 0.0), 32.0);
vec3 specular = vec3(spec_intensity* spec);



    - lighting system multiple lights;
    - Shadows only for directtional light


    - Camera implementation
    - mipmap size
    - uniform buffer matrices
    - bloom
    - Framebuffer alpha transparency
    - vertex array attrubute type in functtion
    - mist https://www.youtube.com/watch?v=qslBNLeSPUc
    - inversing matrix 3D on the cpu
    - Instanced renderering
    - rotate quad (https://www.youtube.com/watch?v=-SQ8TlFZHbY)

GLTF   
    
    - Identical meshes
    - Cubemap - frront facing
    - Lights
    - Mesh name identification for ECS


- ECS
    -Scenes

- matrix dingen kloppend maken
- quattternoons


- available texture slots
- gravity sim
- limit framerate



